# 테스트 주도 개발 시작하기

### 목표
- TDD에 대한 전체적인 개념을 잡기
- 대역을 사용한 테스트 방법

### 원본 책
- [테스트 주도 개발 시작하기](http://www.yes24.com/Product/Goods/89145195)

## 2장

- src/test/java 소스 폴더는 배포 대상이 아니므로 완성되지 않은 코드가 배포되는 것을 방지할 수 있다.
- 데이터는 Enum을 활용

## 3장

- 쉬운 순서부터 테스트 예제를 생각하고 작성하자.
    - 처음부터 완벽한 코드를 작성하기는 힘들다.
- 예외처리부터 테스트하자
    - NPE 같은 예외들을 그때그때 처리할 수 있다.
- 완급 조절
    - 어떻게 구현할지 모르겠으면 작은거부터 점진적으로 생각해보자
    - 문자열 길이나 단순 연산은 익숙해지면 그때 일반화를 하면 된다.
- 테스트를 통과한 뒤에 리팩토링을 하자.
    - 매번 할 필요는 없고 적당한 후보가 보이면 진행한다.
- 테스트 대상 코드의 리팩토링 시점
    - 작은 리팩토링은 바로 리팩토링 진행
        - 상수를 변수로 바꾼다던가 변수 이름을 바꾸는 것
    - 구조에 영향을 주는 리팩토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.
        - 메서드 추출과 같은 리팩토링
    - 구현이 막힌다면 리팩토링을 되돌려서 더 구현한 다음 흐름을 잡아야한다.
        - 코드의 의미나 구조가 더 명확해지면 그때 다시 리팩토링을 시도한다.
- 테스트할 목록을 미리 작성해본다.
    - 생기는 예외상황은 하위 구현 목록으로 작성하기

## 4장

- 설계의 시작은 기능 명세
    - 기능 명세란 입출력값을 생각하고 적는 것이다.
    - 로그인을 예로 들면
        - 입력: 아이디와 암호
        - 결과: 아이디와 암호가 일치하면 성공, 일치하지 않으면 실패
- 테스트 코드를 작성하기 위해 할 수 있어야하는 2가지
    - 테스트할 기능을 실행
        - 클래스, 메서드, 함수 이름
        - 파라미터
    - 실행 결과를 검증
        - 리턴 값
- 필요한 만큼 설계
    - TDD가 전체적인 설계는 해주지 않는다.
    - 다만 일부 설계(클래스, 메서드 등등)를 담당한다.
    - 이는 유연한 설계를 유도할 수 있다.
- 모든 개발이 TDD로 이뤄질 수는 없다.
- TDD를 한다고 설계를 하지 않는 것이 아니다.
    - 요구사항을 분석하며 설계를 하게된다.
    - 하지만 이는 초안일 뿐 언제나 수정이 가능하다는 점이다.
    - TDD는 구현과정을 거치면서 추가할 것은 추가하고 뺄 것은 빼는 과정이다.

- 기능 명세 구체화
    - 구체적인 예를 들어가며 테스트 코드를 작성

### 5장

- JUnit5 3요소
    - JUnit 플랫폼
        - 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API를 제공
    - JUnit 주피터(Jupiter)
        - JUnit5를 위한 테스트 API와 실행 엔진 제공
    - JUnit 빈티지(Vintage)
        - JUnit 3와 JUnit4로 작성된 테스트를 JUnit5 플랫폼에서 실행하기 위한 모듈
- 버전별 설정법
    - https://junit.org/junit5/docs/버전/user-guide/
- 익셉션 발생 유무 검사 메서드
    - assertThrows
    - assertDoseNotThrow
- 모든 검증을 실행해보고 어떤 검증이 틀렸는지 알고 싶을때
    - assertAll을 사용
- 테스트 라이프 사이클
    1. 매번 객체 생성
    2. BeforeEach
    3. Test 메서드
    4. AfterEach
- BeforeAll, AfterAll은 정적 메서드로 선언
    - 테스트 실행전후 한번만 실행

## 6장

- 테스트 구성 요소
    - 상황, 실행, 결과
    - given, when, then
    - 꼭 지킬 필요는 없다.
- 테스트는 외부 상태로부터 자유로워야한다.
    - DB 중복 검사를 테스트한다면
    - 테스트할 때마다 저장했던 아이디를 지워야한다.
    - 또는 트랜잭션을 롤백하는 방법도 있다.
- 외부 상태와의 테스트 어려움
    - 내마음대로 외부 정보를 다룰 순 없어 어려움이 있다.
    - 그래서 대역을 만들어 사용해야한다.

## 7장

- 외부 요인이 테스트에 관여하는 주요 예
    - 파일 시스템 이용
    - DB로부터 데이터를 조회하거나 데이터를 추가
    - 외부 HTTP 서버와 통신
- 외부 요인을 흉내내 간략하게 구현한 뒤 흉내낸 클래스로 테스트 진행
- 대역의 종류
    - 스텁(Stub)
        - 구현을 단순한 것으로 대체
        - 테스트에 맞게 단순히 원하는 동작을 수행
    - 가짜(Fake)
        - 제품에는 적합하지 않지만 실제 동작하는 구현을 제공
        - DB 대신에 메모리를 사용한 것이 예
    - 스파이(Spy)
        - 호출된 내역을 기록
        - 기록한 내용은 테스트 결과를 검증할 때 사용
        - == 스텁
    - 모의(Mock)
        - 기대한 대로 상호작용하는지 행위를 검증
        - 기대한 동작이 없으면 익셉션 발생
        - ==스텁 == 스파이
    
- 스텁, 가짜등 대역 사용
    - 본래 코드를 인터페이스로 선언
    - 인터페이스를 상속받는 스텁 클래스 생성
    - 생성된 스텁 클래스로 테스트
- Mockito (대역 프레임워크)로 다 커버 가능

### 대역 테스트가 좋은 이유

- 외부 상태에 대한 의존도를 낮출 수 있다.
- 대역은 의존하는 대상을 구현하지 않아도 실행 결과를 확인 할 수 있다.
    - DB가 없어도 회원 데이터의 저장 유무를 알 수 있고
    - 메일 서버가 없어도 이메일 발송 요청을 하는지 확인할 수 있다.
    - 암호 검사 기능을 다른 개발자가 만들고 있어도 끝날때까지 기다리지 않고
        - 대역을 만들어 테스트 할 수 있다.
    - 즉 대기 시간을 줄여 개발 속도를 올려준다.

### 과한 모의 객체는 사용하지 않기

- 모의 객체(Mock)을 이용하면 처음에는 대역 클래스를 안만들어도 되니깐 처음에는 편할 수 있다.
    - 하지만 결과 값을 확인하는 수단으로 모의 객체를 사용하기 시작하면 결과 검증코드가 길어지고 복잡해진다.
- 결과 검증 수단으로는 주의해야한다.
    - 특히 DAO나 리포지토리와 같이 저장소에 대한 대역은 메모리를 이용한 가짜 구현이 관리가 더 쉽다.

## 8장

### 테스트가 어려운 코드

- 하드 코딩된 경로
    - 예: D:data\\pay
- 의존 객체를 직접 생성
- 정적 메서드 사용
- 실행시점에 따라 달라지는 결과
    - 예: LocalDate.now(), Random
- 역할이 섞여있는 코드
- 그외 테스트 어려운 코드
    - 메서드 중간에 소캣 통신 코드
    - 콘솔에서 입력받거나 결과를 콘솔에 출력
    - 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final
        - 대역으로 대체가 어려움
    - 테스트 대상의 소스를 소유하고 있지 않을 경우 수정이 어렵다.

### 해결책

- 하드코딩된 상수를 생성자나 메서드 파라미터로 받기
- 의존 대상을 주입 받기
    - 생성나 세터를 통해 의존 대상을 주입
    - 대역을 사용할 수 있어 테스트를 보다 원할하게 작성
- 테스트하고 싶은 코드 분리
    - 별도 기능으로 분리해 테스트한다. 예를들어 클래스로 분리
- 시간이나 임의의 값 생성 기능 분리
    - 생성클래스를 분리해 주입시킨다.
- 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기
    - 연동하기 위한 타입을 따로 만들자
    - 의존하는 대상이 Final 클래스이거나 의존 대상의 호출 메서드가 final 이어서
    - 대역으로 재정의를 못하는 상황일때도 이런 방식을 취하자

## 9장

- 테스트 범위데 따른 테스트 종류
    - 단위 테스트
        - 서비스, 모델
    - 통합 테스트
        - 톰캣, DB
    - 기능 테스트
        - 웹 어플리케이션 전체 테스트
- 기능 테스트 & E2E 테스트
    - 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하는지 테스트
    - 끝에서 끝으로 테스트하기에 E2E테스트로도 볼 수 있다.
    - 기능테스트는 사용자와 동일한 방식으로 기능을 검증해야한다.
        - 예를들어 DB에 직접 SELECT를 사용하여 조회보단 정보 조회 기능을 만들어 확인하는 것이다.
- 통합 테스트
    - 각 구성 요소가 올바르게 연동 되었는지를 확인
        - 예를 들어 회원 가입을 구현했으면
        - 스프링이나 마이바티스 설정이 올바른지
        - SQL 쿼리가 맞는지
        - DB 트랜잭션이 잘 동작하는지를 확인
- 단위 테스트
    - 개별코드나 컴포넌트가 기대한대로 동작하는지 테스트
    - 한 클래스나 한 메서드와 같은 작은 범위를 테스트
- 단위 테스트를 많이 작성하는 이유
    - 결국 연동하고 세팅하는 시간이 길기 때문이다.
    - 또한 자세한 예외처리를 하지 못할 수도 있다.

### 외부 연동 테스트 상황들

- 스프링부트와 DB 통합 테스트
    - 실제 DB를 조회 삭제한다.
    - 하지만 대역을 사용하면 빠르다.
- WireMock을 이용한 REST 클라이언트 테스트
    - HTTP 서버를 흉내내어 대역 테스트를 가능하게 해줌
    - 응답시간 지연을 설정할 수도 있어서 의존성을 낮춰줌
- 스프링부트 내장 서버를 이용한 API 기능 테스트
    - 스프링부트는 테스트에서 웹환경을 구동할 수 있는 기능 제공

## 10장

- 테스트 유지보수
    - 실패한 테스트 코드를 방치하면 스노우볼이 굴러간다.
    - 유지보수는 매우 중요하다.

### TDD를 처음할 때 주의 사항

- 변수나 필드를 사용해서 기댓값 표현하지 않기
    - 다른 사람이 변수와 필드를 오가며 테스트 코드를 이해해야하는 복잡함이 있다.
    - 단언할 때 상수로 fix 해놓자
- 두개 이상을 검증하지 않기
    - 단일 원칙 책임을 따르자(객체지향적으로)
- 정확하게 일치하는 값으로 모의 객체 설정하지 않기
    - 하나라도 바뀌면 테스트가 실패하기에 좀더 범용성있게 작성
- 과도하게 구현 검증하지 않기
    - 내부 구현은 언제든지 바뀔 수 있기 때문에
    - 실행 결과를 검증해야한다.
- 셋업을 이용해서 중복된 상황을 설정하지 않기
    - 처음에는 여러 메서드에 동일한 상황을 적용하는 것이 편리하지만
    - 유지보수에는 방해가 된다.
    - 테스트 메서드는 자체적으로 검증하는 내용을 완전히 기술하고 있어야한다.
- 통합 테스트에서 데이터 공유 주의하기
    - 두 가지 초기화 데이터로 구분해야함
        - 모든 테스트가 같은 값을 사용하는 데이터
            - 예를들어 코드값 데이터
        - 테스트 메서드에서만 필요한 데이터
            - 중복 ID 검사를 위한 회원 데이터
- 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
- 실행 환경이 다르다고 실패하지 않기
    - 전형적인 예: 파일경로
    - 특정 os환경에서만 통과해야하는 경우는
        - EnableOnOs
        - DisableOnOs
- 실행 시점이 다르다고 실패하지 않기
    - 시간으로 실패하지 않기
    - 랜덤하게 실패하지 않기
        - mock으로 인자랑 리턴값 픽스
- 필요하지 않은 값은 설정하지 않기
    - 예를들어 중복 아이디 검사에는 이메일, 패스워드등은 필요없다.
- 단위 테스트를 위한 객체 생성 보조 클래스
    - 빌더를 이용해 더 유용하게 테스트용 생성 클래스를 만들자.
- 조건부로 검증하지 않기
    - assert에 if문을 걸지마라
- 통합 테스트는 필요하지 않은 범위까지 연동하지 않기
    - 예를들어 SpringBootTest 어노테이션은 스프링 빈부터 시작해서 다 초기화하는데
    - DB와의 통합테스트를 위해서라면 JdbcTest로도 간결하게 가능하다.
- 더 이상 쓸모 없는 테스트 코드
    - 테스트 커버리지를 높이기 위해 검증을 할 필요는 없다.
    - 의미 있는 테스트 코드만 남겨놓자

## 11장

- TDD를 안하면 스트레스 증가(사실은 테스트 코드)
- 회귀 테스트란?
    - 코드를 수정해도 기존 코드가 올바르게 동작하는지 확인하기 위한 테스트
- 레거시 코드에 대한 테스트 추가
- TDD와 개발시간
    - 개발시간은 아래와 같다.
        - 코딩
        - 디버깅
        - 테스트
    - TDD를 하게되면 코딩은 늘지만 디버깅과 테스트가 줄어든다.
    - 결과적으로 이득이다.

## 부록 A: JUnit5에 추가된 것

- TimeOut으로 테스트 실행시간 검증
- TempDir로 임시 폴더 생성
- 태깅과 필터링 (Tag)

## 부록 C: Mockito

- Mokito를 이용한 모의 객체 생성과 스텁 설정
    
    ```java
    // 1) 모의 객체 생성
    GameNumGen genMock = mock(GameNumGen.class);
    
    // 2) 스텁 설정
    given(genMock.generate(GameLevel.EASY)).willReturn("123");
    
    // 3) 스텁 설정에 매칭되는 메서드 실행
    String num = genMock.generate(GameLevel.EASY);
    ```
    
- 설정 종류
    - willReturn → 원하는 출력값
    - willThrow → 익셉션 발생
        - 타입, 객체 둘다 가능
- 스텁 설정을 하지않으면
    - 참조타입은 null 리턴
    - 기본타입이면 int → 0, boolean → false
- ArgumentMatchers
    - Mockito, BDDMockito 클래스가 상속하고 있음
    - any(): 임의의 타입 일치
    - anyInt()등등: 기본 타입 일치
    - matches(): 정규표현식을 사용한 String 값 일치 여부
    - eq(): 특정값과 일치여부
- 인자를 any로 사용했으면 모든 인자를 any로 사용해야한다.
    - 내부적으로 ArgumentMatcher을 등록하기 때문이다.
    - 정확한 인자랑 같이 사용하고 싶으면 ArgumentMatchers.eq()를 사용
- 행위 검증
    - 실제로 모의 객체가 불렸는지 검증
    
    ```java
    then(모의객체).should().불러야할 메서드
    ```
    
- 인자 캡쳐
    - ArgumentCaptor를 선언해 인자를 저장할 수 있다.
    - 불러온 메서드에게 주는 인자값을
